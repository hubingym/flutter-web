import 'package:flutter_web/foundation.dart';

import 'keyboard_key.dart';
import 'keyboard_maps.dart';
import 'raw_keyboard.dart';

class RawKeyEventDataFuchsia extends RawKeyEventData {
  const RawKeyEventDataFuchsia({
    this.hidUsage = 0,
    this.codePoint = 0,
    this.modifiers = 0,
  })  : assert(hidUsage != null),
        assert(codePoint != null),
        assert(modifiers != null);

  final int hidUsage;

  final int codePoint;

  final int modifiers;

  @override
  String get keyLabel => codePoint == 0 ? null : String.fromCharCode(codePoint);

  @override
  LogicalKeyboardKey get logicalKey {
    if (codePoint != 0) {
      return LogicalKeyboardKey(
        LogicalKeyboardKey.unicodePlane |
            codePoint & LogicalKeyboardKey.valueMask,
        keyLabel: keyLabel,
        debugName: kReleaseMode ? null : 'Key $keyLabel',
      );
    }

    LogicalKeyboardKey newKey =
        kFuchsiaToLogicalKey[hidUsage | LogicalKeyboardKey.hidPlane];
    if (newKey != null) {
      return newKey;
    }

    const int fuchsiaKeyIdPlane = 0x00300000000;
    newKey ??= LogicalKeyboardKey(
      fuchsiaKeyIdPlane | hidUsage | LogicalKeyboardKey.autogeneratedMask,
      debugName: kReleaseMode ? null : 'Ephemeral Fuchsia key code $hidUsage',
    );
    return newKey;
  }

  @override
  PhysicalKeyboardKey get physicalKey =>
      kFuchsiaToPhysicalKey[hidUsage] ?? PhysicalKeyboardKey.none;

  bool _isLeftRightModifierPressed(
      KeyboardSide side, int anyMask, int leftMask, int rightMask) {
    if (modifiers & anyMask == 0) {
      return false;
    }
    switch (side) {
      case KeyboardSide.any:
        return true;
      case KeyboardSide.all:
        return modifiers & leftMask != 0 && modifiers & rightMask != 0;
      case KeyboardSide.left:
        return modifiers & leftMask != 0;
      case KeyboardSide.right:
        return modifiers & rightMask != 0;
    }
    return false;
  }

  @override
  bool isModifierPressed(ModifierKey key,
      {KeyboardSide side = KeyboardSide.any}) {
    assert(side != null);
    switch (key) {
      case ModifierKey.controlModifier:
        return _isLeftRightModifierPressed(
            side, modifierControl, modifierLeftControl, modifierRightControl);
      case ModifierKey.shiftModifier:
        return _isLeftRightModifierPressed(
            side, modifierShift, modifierLeftShift, modifierRightShift);
      case ModifierKey.altModifier:
        return _isLeftRightModifierPressed(
            side, modifierAlt, modifierLeftAlt, modifierRightAlt);
      case ModifierKey.metaModifier:
        return _isLeftRightModifierPressed(
            side, modifierMeta, modifierLeftMeta, modifierRightMeta);
      case ModifierKey.capsLockModifier:
        return modifiers & modifierCapsLock != 0;
      case ModifierKey.numLockModifier:
      case ModifierKey.scrollLockModifier:
      case ModifierKey.functionModifier:
      case ModifierKey.symbolModifier:
        return false;
    }
    return false;
  }

  @override
  KeyboardSide getModifierSide(ModifierKey key) {
    KeyboardSide findSide(int leftMask, int rightMask, int combinedMask) {
      final int combined = modifiers & combinedMask;
      if (combined == leftMask) {
        return KeyboardSide.left;
      } else if (combined == rightMask) {
        return KeyboardSide.right;
      } else if (combined == combinedMask) {
        return KeyboardSide.all;
      }
      return null;
    }

    switch (key) {
      case ModifierKey.controlModifier:
        return findSide(
            modifierLeftControl, modifierRightControl, modifierControl);
      case ModifierKey.shiftModifier:
        return findSide(modifierLeftShift, modifierRightShift, modifierShift);
      case ModifierKey.altModifier:
        return findSide(modifierLeftAlt, modifierRightAlt, modifierAlt);
      case ModifierKey.metaModifier:
        return findSide(modifierLeftMeta, modifierRightMeta, modifierMeta);
      case ModifierKey.capsLockModifier:
        return (modifiers & modifierCapsLock == 0) ? null : KeyboardSide.all;
      case ModifierKey.numLockModifier:
      case ModifierKey.scrollLockModifier:
      case ModifierKey.functionModifier:
      case ModifierKey.symbolModifier:
        return null;
    }

    assert(false, 'Not handling $key type properly.');
    return null;
  }

  static const int modifierNone = 0x0;

  static const int modifierCapsLock = 0x1;

  static const int modifierLeftShift = 0x2;

  static const int modifierRightShift = 0x4;

  static const int modifierShift = modifierLeftShift | modifierRightShift;

  static const int modifierLeftControl = 0x8;

  static const int modifierRightControl = 0x10;

  static const int modifierControl = modifierLeftControl | modifierRightControl;

  static const int modifierLeftAlt = 0x20;

  static const int modifierRightAlt = 0x40;

  static const int modifierAlt = modifierLeftAlt | modifierRightAlt;

  static const int modifierLeftMeta = 0x80;

  static const int modifierRightMeta = 0x100;

  static const int modifierMeta = modifierLeftMeta | modifierRightMeta;

  @override
  String toString() {
    return '$runtimeType(hidUsage: $hidUsage, codePoint: $codePoint, modifiers: $modifiers, '
        'modifiers down: $modifiersPressed)';
  }
}
